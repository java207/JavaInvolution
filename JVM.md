# JVM

## 堆

**线程共享**

内存分配 垃圾回收

## 栈

**线程私有**

> 由栈帧组成，栈帧内包括：局部变量表、操作数栈、动态链接、方法出口信息

### 虚拟机栈

> 局部变量表：基本数据类型、对象引用

> 为Java方法服务

### 本地方法栈

> 存储的数据类型与虚拟机栈一样

> 为Native方法服务

## 方法区

**线程共享**

> 存储类信息、常量、静态变量、即时编译器编译后的代码

> 运行时常量池
>
> 1.8 方法区实现由永久代改为元空间

## 程序计数器

**线程私有**

> 流程控制

> 记录线程当前执行位置，以便线程切换

------

## 常量池

### class文件常量池/类文件常量池/静态常量池

> Java文件编译为class文件时生成class文件常量池，每个class都有一个

> 类相关信息、字面量、符号引用

### 运行时常量池（元空间）

> 类加载进内存中时生成运行时常量池，每个class都有一个

> 用于动态加载类信息，在解析阶段将符号引用替换为直接引用

1.6 在方法区，包含String常量池

1.7 在方法区，不包含String常量池

**1.8 在方法区，方法区实现由永久代改为元空间**

### String常量池（堆）

1.6 在方法区

1.7 在堆中

**1.8 在堆中**

**String.internl()**

1.6 检查常量池，当字符串在常量池中存在，返回该串的引用，若不存在，在常量池中创建该串，并返回该串的引用

**1.7 检查常量池，当字符串在常量池中存在，返回该串的引用，若不存在，将堆中该串的引用复制到常量池中，并返回该引用**

### 基本数据类型常量池

> 除了Float、Double外的六种基本数据类型都实现了常量池

> Byte、Integer、Short、Long范围[-128, 127]

> Character范围[0, 127]

> Boolean范围{True, False}

------

```
字面量：文本字符串、被声明为final的常量值、基本数据类型的值、其他

符号引用：类和结果的完全限定名、字段名称和描述符、方法名称和描述符
```

## GC

### 可达性分析

通过一系列的成为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

#### 引用计数法的缺点

- 需要额外的空间来存储计数器，更新计数操作频繁
- 无法处理循环引用对象

#### GC Roots

可作为GC Roots的对象包含以下几种：

- 虚拟机栈中引用的对象

> 虚拟机栈帧中本地变量表引用的对象，即正常在堆中创建的实例对象

- 方法区中类静态属性引用的对象

> 静态对象，位于方法区中，随着类的加载而加载

- 方法区中常量引用的对象

> 常量对象，位于方法区中

- 本地方法栈中Native方法引用的对象

> 使用JNI技术时，JVM会在Native方法栈中保存这些对象的引用，这些引用的对象也可以作为GC Roots

#### 引用的类型

**强引用 （Strong Reference）**

即平常new创建对象时的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

**软引用（Soft Reference）**

描述一些还有用但并非必须的对象。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。

> 软引用可以和引用队列（referenceQueue）联用，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。

应用场景：软引用一般用来实现内存敏感的缓存，如果有空闲内存就可以保留缓存，当内存不足时就清理掉，这样就保证使用缓存的同时不会耗尽内存，如图片缓存框架中缓存图片就是通过软引用实现。

**弱引用（Weak Reference）**

如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

> 弱引用也可以和引用队列（referenceQueue）联用

**虚引用（Phantom Reference）**

“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
虚引用主要用来跟踪对象被垃圾回收器回收的活动。

> 虚引用与软引用、弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。

**程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。**

### 垃圾收集器

#### CMS

**第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作**

- 初始标记（initial mark），仅标记GC Roots能直接关联到的对象（活对象），STW

- 并发标记（concurrent mark），同时开启GC和用户线程，对初始标记所标记过的对象进行追踪，对所有关联的对象进行标记（活对象）

  > 由于并发标记期间用户线程会继续运行，所以标记期间可能会导致部分标记的对象发生变动，变动可分为两种：
  >
  > - 本来可达的对象，变得不可达（浮动垃圾）
  > - 本来不可达的内存，变得可达

- 重新标记（remark），对并发标记期间产生的变动进行修正，停顿时间比初始标记稍长，但远远短于并发标记，STW

  > remark阶段标记的也是活对象，修正的是并发标记期间的第二种变动，所以第一种变动就成了浮动垃圾
  >
  > 由于第二种变动产生了新的可达对象，如果没有重新标记，则会对其进行错误地回收

- 并发清除（concurrent sweep），开启用户线程，同时GC线程开始对未标记的区域做清扫

![CMS 垃圾收集器 ](https://javaguide.cn/assets/img/CMS%E6%94%B6%E9%9B%86%E5%99%A8.4ffa2c2e.png)

**缺点**

- “标记-清除”算法会产生内存碎片

- 对CPU资源敏感（GC线程与用户线程抢占CPU）
- 产生浮动垃圾



## 类加载

### 类加载过程



### 类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

- **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。

- **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。

- **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

**双亲委派模型**

每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

**双亲委派模型的优点**

- 保证 Java 程序的稳定运行，可以避免类的重复加载
- 保证 Java 的核心 API 不被篡改，比如我们编写一个称为 `java.lang.Object` 类，那么程序运行的时候，系统就会出现多个不同的 `Object` 类

**打破双亲委派**

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法
